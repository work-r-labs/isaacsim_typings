from __future__ import annotations
from functools import partial
import omni as omni
from omni.kit.widget.stage.stage_widget import StageWidget
from omni import ui
from pxr import Sdf
import pxr.Usd
from pxr import Usd
import weakref as weakref
__all__: list = ['filter_prims', 'SelectionWatch', 'RelationshipTargetPicker', 'RelationshipArrayModel', 'SdfRelationshipArraySingleEntryModel', 'SdfRelationshipArrayItemModel', 'RelationshipEditWidget']
class RelationshipArrayModel(omni.ui._ui.AbstractValueModel):
    def __init__(self, stage, property_paths, additional_widget_kwargs):
        ...
    def _on_usd_changed(self, *args, **kwargs):
        ...
    def _set_dirty(self, *args, **kwargs):
        ...
    def _update_shared_targets(self):
        ...
    def clean(self):
        ...
    def get_property_paths(self):
        ...
    def get_relationship_paths(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def get_targets(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def get_value(self):
        ...
    def is_ambiguous(self) -> bool:
        ...
    def set_targets(self, targets: typing.List[pxr.Sdf.Path]):
        ...
    def set_value(self, targets: typing.List[pxr.Sdf.Path]):
        ...
class RelationshipEditWidget:
    """
    
        DEPRECATED!
    
        Existing extensions depend on this class but the UI has been updated. Please update your extensions.
        
    """
    def __init__(self, stage, attr_name, prim_paths, additional_widget_kwargs = None):
        ...
    def _build(self):
        ...
    def _set_dirty(self):
        ...
    def clean(self):
        ...
    def get_all_comp_ambiguous(self) -> typing.List[bool]:
        ...
    def get_property_paths(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def get_relationship_paths(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def get_targets(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def is_ambiguous(self) -> bool:
        ...
    def set_targets(self, targets: typing.List[pxr.Sdf.Path]):
        ...
    def set_value(self, targets: typing.List[pxr.Sdf.Path]):
        ...
class RelationshipTargetPicker:
    @staticmethod
    def _on_select(weak_self: callable):
        ...
    def __init__(self, stage, filter_type_list, filter_lambda, additional_widget_kwargs):
        ...
    def _on_selection_changed(self, paths):
        ...
    def clean(self):
        ...
    def show(self, targets_limit, on_targets_selected: typing.Optional[typing.Callable] = None):
        ...
class RelationshipTargetPickerOld:
    """
    
        DEPRECATED
        
    """
    def __init__(self, stage, relationship_widget, filter_type_list, filter_lambda, on_add_targets: typing.Optional[typing.Callable] = None):
        ...
    def _on_selection_changed(self, paths):
        ...
    def clean(self):
        ...
    def show(self, targets_limit):
        ...
class SdfRelationshipArrayItemModel(omni.ui._ui.AbstractItemModel):
    class SdfRelationshipPathItem(omni.ui._ui.AbstractItem):
        """
        Single item of the model
        """
        def __init__(self, stage: pxr.Usd.Stage, property_paths: typing.List[pxr.Sdf.Path], index: int, self_refresh: bool, metadata: dict, additional_widget_kwargs = None):
            ...
        def destroy(self):
            ...
        def is_ambiguous(self) -> bool:
            ...
    def __init__(self, stage: pxr.Usd.Stage, property_paths: typing.List[pxr.Sdf.Path], metadata: dict, delegate, additional_widget_kwargs):
        ...
    def _on_usd_changed(self, *args, **kwargs):
        ...
    def _repopulate_entries(self, value):
        ...
    def _set_dirty(self, *args, **kwargs):
        ...
    def clean(self):
        ...
    def drop(self, target_item, source, drop_location = -1):
        ...
    def drop_accepted(self, target_item, source, drop_location = -1):
        ...
    def get_attribute_paths(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def get_drag_mime_data(self, item):
        ...
    def get_item_children(self, item):
        """
        Returns all the children when the widget asks it.
        """
    def get_item_value_model(self, item, column_id):
        ...
    def get_item_value_model_count(self, item):
        ...
    def get_property_paths(self) -> typing.List[pxr.Sdf.Path]:
        ...
    def get_value(self, *args, **kwargs):
        ...
    def is_ambiguous(self) -> bool:
        ...
    def set_value(self, *args, **kwargs):
        ...
    @property
    def value_model(self):
        ...
class SdfRelationshipArraySingleEntryModel(omni.ui._ui.SimpleStringModel):
    def __init__(self, stage: pxr.Usd.Stage, property_paths: typing.List[pxr.Sdf.Path], index: int):
        ...
    def _on_usd_changed(self, *args, **kwargs):
        ...
    def _set_dirty(self, *args, **kwargs):
        ...
    def clean(self):
        ...
    def get_value(self):
        ...
    def get_value_as_string(self):
        ...
    def set_value(self, value):
        ...
    def set_value_as_string(self, value):
        ...
class SelectionWatch:
    def __init__(self, stage, on_selection_changed_fn, filter_type_list, filter_lambda, tree_view = None):
        ...
    def _on_widget_selection_changed(self, selection):
        ...
    def clear_selection(self):
        ...
    def enable_filtering_checking(self, enable: bool):
        """
        
                It is used to prevent selecting the prims that are filtered out but
                still displayed when such prims have filtered children. When `enable`
                is True, SelectionWatch should consider filtering when changing Kit's
                selection.
                
        """
    def reset(self, targets_limit):
        ...
    def set_filtering(self, filter_string: typing.Optional[str]):
        ...
    def set_tree_view(self, tree_view):
        ...
class SelectionWatchOld:
    """
    
        DEPRECATED
        
    """
    def __init__(self, stage, on_selection_changed_fn, filter_type_list, filter_lambda, tree_view = None):
        ...
    def _on_widget_selection_changed(self, selection):
        ...
    def clear_selection(self):
        ...
    def enable_filtering_checking(self, enable: bool):
        """
        
                It is used to prevent selecting the prims that are filtered out but
                still displayed when such prims have filtered children. When `enable`
                is True, SelectionWatch should consider filtering when changing Kit's
                selection.
                
        """
    def reset(self, targets_limit):
        ...
    def set_filtering(self, filter_string: typing.Optional[str]):
        ...
    def set_tree_view(self, tree_view):
        ...
def filter_prims(stage, prim_list, type_list):
    ...
